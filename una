#!/bin/bash

bold="$(tput bold)"
normal="$(tput sgr0)"

set -e

fatal() {
    echo -e "${bold}fatal error${normal}: $*"
    kill $$
}

sshell_exit() {
    kill $$
}

info() {
    echo -e "${bold}info${normal}: $*"
}

trim_string() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    printf '%s' "$var"
}

update_command() {
    local pkg="$1"

    python3 - "${pkg}" <<'EOF'
import requests, sys

try:
    resp = requests.get('https://mpr.makedeb.org/packages-meta-ext-v1.json.gz')
    paklist = resp.json()
    all_packages = [ x["Name"] for x in paklist ]
    all_versions = [ x["Version"] for x in paklist ]

    data = sys.argv[1]

    if all_versions[all_packages.index(data.split(' ')[0])] != data.split(' ')[1]:
        print(f"_install {data.split(' ')[0]} force")
except:
    print('')
EOF
}

_help() {
    echo -e "${bold}Una - a complete MPR helper${normal}"
    echo
    echo "Syntax: una <COMMAND> [PACKAGE]"
    echo
    echo "commands:"
    echo
    echo "  install     Install a package."
    echo "  update      Update the APT and MPR cache."
    echo "  upgrade     Upgrade all installed packages."
    echo "  remove      Remove a package."
    echo "  list        List installed packages."
    echo "  info        Show package information."
    echo "  search      Search for packages."
    echo "  help        Show the usage."
    echo "  clone       Clone a package from the MPR."
    echo
    echo "${bold}Do not use 'apt remove' or 'apt purge' on MPR packages."
    echo "The package will get reinstalled when updating if an update for it is available."
    echo "Instead, use 'una remove' (replacement for 'apt purge' for MPR packages)."
    echo
    echo "Run "'`una update`'" if you're running una for the first time.${normal}"
}

_install() {
    sudo mkdir -p /var/lib/una

    pkgname="${1:?}"

    if [[ "$2" != "force" ]]; then
        LC_ALL=C dpkg-query -W -f='${Status}' "${pkgname}" 2>/dev/null | grep -q "ok installed" && (
            fatal "${pkgname} is already installed"
        ) || true
    fi

    info 'creating build directory'
    rm -rf "${HOME}/.cache/una/pkgs/${pkgname}" "${HOME}/.cache/una/pkgs/${pkgname}-git"
    mkdir -p ~/.cache/una/pkgs && cd ~/.cache/una/pkgs

    info "cloning ${pkgname}"
    LC_ALL=C git clone "https://mpr.makedeb.org/${pkgname}.git" 2>&1 | grep -q 'empty repository' && \
        { LC_ALL=C git clone "https://mpr.makedeb.org/${pkgname}-git.git" 2>&1 | grep -q 'empty repository' && \
            ( sudo apt-get install -y "${pkgname}" && ( ( rmdir "${HOME}/.cache/una/pkgs/${pkgname}" &>/dev/null; \
            touch "/tmp/${pkgname}.lock" ) || true ) || fatal "this package doesn't exist or an error occured" ) || pkgname="${pkgname}-git"; } \
        || fatal 'something went wrong'

    if [[ "$2" != "force" ]]; then
        LC_ALL=C dpkg-query -W -f='${Status}' "${pkgname}" 2>/dev/null | grep -q "ok installed" && return || true;
    elif [[ "$2" == "force" ]] && [[ -f "/tmp/${pkgname}.lock" ]]; then
        rm -f "/tmp/${pkgname}.lock"; return;
    fi

    rm -f "/tmp/${pkgname}.lock"

    source "${pkgname}/PKGBUILD"

    # new_optdepends=()
    # for depend in "${optdepends[@]}"; do
    #     new_optdepends+=( "${depend%:*}")
    # done

    source /etc/os-release
    codename_depends="${VERSION_CODENAME}_depends"
    codename_makedepends="${VERSION_CODENAME}_makedepends"
    [[ "${!codename_depends}" != "" ]] && eval "depends=(\${$codename_depends[*]})"
    [[ "${!codename_makedepends}" != "" ]] && eval "makedepends=(\${$codename_makedepends[*]})"

    info "installing dependencies of ${pkgname}"
    for depend in "${depends[@]}" "${makedepends[@]}" "${checkdepends[@]}"; do # "${new_optdepends[@]}"; do
        dpkg-query -W -f='${Status}' "${depend}" 2>/dev/null | grep -q "ok installed" && true || _install "$depend"
        sudo apt-mark auto "$depend" &>/dev/null
        pkgname="${1:?}"
    done

    pkgname="${1:?}"

    echo "building ${pkgname}"
    cd "${HOME}/.cache/una/pkgs/${pkgname}" && makedeb -i

    sudo touch /var/lib/una/status && sudo cp /var/lib/una/status /var/lib/una/status.old
    grep -q "^${pkgname} " /var/lib/una/status && grep -v "^${pkgname} " /var/lib/una/status 2>/dev/null | sudo tee /var/lib/una/status &>/dev/null
    printf "\n${pkgname} $(dpkg-query --showformat='${Version}' --show ${pkgname})" | sudo tee -a /var/lib/una/status &>/dev/null
    grep -v "^$" /var/lib/una/status 2>/dev/null | sudo tee /var/lib/una/status &>/dev/null
}

_upgrade() {
    if [[ "$1" == "force" ]]; then
        _install "$1" force; return;
    fi

    [[ "$1" == "updates" ]] || info 'upgrading MPR packages'
    grep -v '^$' /var/lib/una/status | while IFS= read -r line; do
        [[ $(update_command "$line") == "" ]] && continue
        [[ "$1" == "updates" ]] && update_command "$line" || true
        [[ "$1" == "updates" ]] && continue || true
        $(update_command "$line")
    done
    [[ "$1" == "updates" ]] && return || true

    echo
    info 'upgrading APT packages'
    sudo apt-get upgrade -y
}

_remove() {
    pkgname="${1:?}"

    sudo apt-get purge -y "${pkgname}"

    sudo touch /var/lib/una/status && sudo cp /var/lib/una/status /var/lib/una/status.old
    grep -q "^${pkgname} " /var/lib/una/status && grep -v "^${pkgname} " /var/lib/una/status 2>/dev/null | grep -v "^$" 2>/dev/null | sudo tee /var/lib/una/status &>/dev/null
}

_search() {
    pkgname="${1:?}"

    info 'showing MPR packages'

    [[ ${#pkgname} -lt 2 ]] && fatal 'search string too short (the length should be greater than 1)'

    CURL=$(curl -s "https://mpr.makedeb.org/rpc?v=5&type=search&arg=${pkgname}")
    paste <(echo "$(echo "$CURL" | jq --raw-output '.results[].Name'):") <(echo "$CURL" | jq --raw-output '.results[].Description')

    echo
    info 'showing APT packages'
    apt-cache search "${pkgname}" 2>/dev/null
}

_info() {
    pkgname="${1:?}"

    python3 - "${pkgname}" <<'EOF' || ( apt-cache show "${pkgname}" 2>/dev/null || fatal "this package doesn't exist or you're not connected to a network" )
import requests, sys, os

from datetime import datetime

class color:
   PURPLE = '\033[95m'
   CYAN = '\033[96m'
   DARKCYAN = '\033[36m'
   BLUE = '\033[94m'
   GREEN = '\033[92m'
   YELLOW = '\033[93m'
   RED = '\033[91m'
   BOLD = '\033[1m'
   UNDERLINE = '\033[4m'
   END = '\033[0m'

try:
    resp = requests.get(f"https://mpr.makedeb.org/rpc?v=5&type=info&arg={sys.argv[1]}")
    pkginfo = resp.json()
    print(color.BOLD + 'Name:' + color.END, pkginfo['results'][0]['Name'])
    print(color.BOLD + 'Maintainer:' + color.END, pkginfo['results'][0]['Maintainer'])
    print(color.BOLD + 'Last modified:' + color.END, datetime.fromtimestamp(pkginfo['results'][0]['LastModified']))
    print(color.BOLD + 'Description:' + color.END, pkginfo['results'][0]['Description'])
    print(color.BOLD + 'Upstream URL:' + color.END, pkginfo['results'][0]['URL'])
    print(color.BOLD + 'Version:' + color.END, pkginfo['results'][0]['Version'])
    print(color.BOLD + 'Git Clone URL:' + color.END, 'https://mpr.makedeb.org/' + pkginfo['results'][0]['Name'] + '.git')
    print(color.BOLD + 'Depends:' + color.END)
    for i, depend in enumerate(pkginfo['results'][0]['Depends']):
        if i == 5:
            print('    ...')
            break
        else:
            print(f"{color.BOLD}  - {color.END}{depend}")
except:
    sys.exit(1)
EOF
}

_update_command() {
    info 'updating APT cache'
    sudo apt-get update &>/dev/null || true
    info 'updating MPR cache'
    { curl -qs 'https://mpr.makedeb.org/packages-meta-ext-v1.json.gz' | gunzip | sudo tee /var/lib/una/cache &>/dev/null; } || fatal 'are you sure you are connected to a network?'
}

_clone() {
    pkgname="$1"

    [[ -d "$pkgname" ]] && { info "The directory ${pkgname} already exists. Do you want to overwrite it? (press ENTER to proceed, or ^C to exit)"; }
    read; rm -rf "$pkgname"
    LC_ALL=C git clone "https://mpr.makedeb.org/${pkgname}.git" 2>&1 | grep -q 'empty repository' && \
        { rm -rf "${pkgname}"; fatal "this MPR package doesn't exist or an error occured"; } || info "Cloned the git repo"
}

[[ "$EUID" == "0" ]] && fatal 'running as root can cause problems'

# check if lockfile exists
LOCKFILE=/tmp/una.lock
if [[ -e /tmp/una.lock ]] && kill -0 "$(cat "${LOCKFILE}")"; then
    fatal "already running as PID $(cat "${LOCKFILE}")"
    exit
fi

# create lockfile
trap "rm -f "${LOCKFILE:?}"; exit" INT TERM EXIT
echo $$ > ${LOCKFILE}

if [[ ! -d '/var/lib/una' ]] || { [[ ! -f '/var/lib/una/status' ]] || [[ ! -f '/var/lib/una/cache' ]]; }; then
    info 'creating una directory'
    sudo mkdir -p /var/lib/una
    sudo touch /var/lib/una/status /var/lib/una/cache
    echo
    info 'looks like you are a new user'
    info "run una update every once in a while to update una's package cache"
    info "you might face issues if it's outdated"
    echo && sleep 3

    _update_command
    echo
fi

if [[ "$1" == "install" ]] && [[ "$2" != "" ]]; then
	_install "$2";
elif [[ "$1" == "update" ]]; then
	_update_command;
elif [[ "$1" == "updates" ]]; then
    _upgrade updates;
elif [[ "$1" == "list" ]]; then
    dpkg -l;
elif [[ "$1" == "clone" ]]; then
    _clone "$2";
elif [[ "$1" == "remove" ]] || [[ "$1" == "purge" ]]; then
    _remove "$2";
elif [[ "$1" == "upgrade" ]]; then
    _upgrade "$2";
elif [[ "$1" == "search" ]] && [[ "$2" != "" ]]; then
    _search "$2";
elif { [[ "$1" == "info" ]] || [[ "$1" == "show" ]]; } && [[ "$2" != "" ]]; then
    _info "$2";
elif [[ -z "$1" ]] || [[ "$1" == "help" ]]; then
    _help;
fi

# remove lockfile
rm -f "${LOCKFILE:?}"
