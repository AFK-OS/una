#!/bin/bash

bold="$(tput bold)"
normal="$(tput sgr0)"

red=$'\e[1;31m'
green=$'\e[1;32m'
yellow=$'\e[1;33m'
blue=$'\e[1;34m'
magenta=$'\e[1;35m'
cyan=$'\e[1;36m'

version='v1.2.1'

set -e

echo "${cyan}una ${version}${normal}" 1>&2

fatal() {
    echo -e "${bold}${red}>>${normal}${bold} $*${normal}" 1>&2
    kill $$
}

sshell_exit() {
    kill $$
}

info() {
    echo -e "${bold}${blue}>>${normal}${bold} $*${normal}"
}

_spinner() {
    pid="$!"
    while kill -0 "$pid" 2>/dev/null; do
        echo -en "${bold}${blue}>>${normal}${bold} $* ${normal}" 1>&2
        BCK=''
        for char in ⣾ ⣽ ⣻ ⢿ ⡿ ⣟ ⣯ ⣷; do
            echo -en "${BCK}${char}" 1>&2
            sleep 0.1; BCK=$'\b'
        done
        echo -en "\033[2K\r" 1>&2
    done
}

upgrade_command() {
    local pkg="$1"

    python3 - "${pkg}" <<'EOF'
import os, sys, json, requests

try:
    with open(os.path.expanduser('~/.cache/una/cache')) as pakfile:
        paklist = json.load(pakfile)

        all_packages = [ x["Name"] for x in paklist ]
        all_versions = [ x["Version"] for x in paklist ]

        data = sys.argv[1]

        if data.split(' ')[1] not in all_versions[all_packages.index(data.split(' ')[0])]:
            print(f"_install {data.split(' ')[0]} force")
except:
    print('')
EOF
}

_help() {
    echo
    echo "Syntax: una <COMMAND> [PACKAGE]"
    echo
    echo "commands:"
    echo
    echo "  install     Install a package."
    echo "  update      Update the APT and MPR cache."
    echo "  upgrade     Upgrade all installed packages."
    echo "  remove      Remove a package."
    echo "  list        List installed packages."
    echo "  info        Show package information."
    echo "  search      Search for packages."
    echo "  clone       Clone a package from the MPR."
    echo "  help        Show the usage."
    echo
    echo "${bold}Do not use 'apt remove' or 'apt purge' on MPR packages."
    echo "The package will get reinstalled when updating if an update for it is available."
    echo "Instead, use 'una remove' (replacement for 'apt purge' for MPR packages).${normal}"
}

_install() {
    sudo mkdir -p /var/lib/una

    local pkgname="${1:?}"

    if [[ "$2" != "force" ]]; then
        LC_ALL=C dpkg-query -W -f='${Status}' "${pkgname}" 2>/dev/null | grep -q "ok installed" && {
            [[ "$3" == git ]] && return || fatal "${pkgname} is already installed";
        } || true
    fi

    echo
    info 'clearing old build directory'
    rm -rf "${HOME}/.cache/una/pkgs/${pkgname}" "${HOME}/.cache/una/pkgs/${pkgname}-git"
    echo
    info 'creating build directory'
    mkdir -p ~/.cache/una/pkgs && cd ~/.cache/una/pkgs

    if [[ "$3" == "git" ]]; then
        info "cloning ${pkgname}"
        LC_ALL=C git clone "https://mpr.makedeb.org/${pkgname}.git" 2>&1 | grep -q 'empty repository' \
            && { echo; fatal "this package doesn't exist"; } || true
    else
        force="$2"

        info "cloning ${pkgname}"
        LC_ALL=C git clone "https://mpr.makedeb.org/${pkgname}.git" 2>&1 | grep -q 'empty repository' \
            && { { apt-cache show "${pkgname}" &>/dev/null && sudo apt-get install -y "${pkgname}"; } \
            && { { rm -rf "${HOME}/.cache/una/pkgs/${pkgname}" &>/dev/null; touch "/tmp/${pkgname}.lock"; } } \
            || { _install "${pkgname}-git" "$force" git; }; return; } \
            || true

        if [[ "$force" != "force" ]]; then
            LC_ALL=C dpkg-query -W -f='${Status}' "${pkgname}" 2>/dev/null | grep -q "ok installed" && return || true;
            LC_ALL=C dpkg-query -W -f='${Status}' "${pkgname}-git" 2>/dev/null | grep -q "ok installed" && return || true;
        elif [[ "$2" == "force" ]] && [[ -f "/tmp/${pkgname}.lock" ]]; then
            rm -f "/tmp/${pkgname}.lock"; return;
        fi
    fi

    source /etc/os-release

    depends=()
    makedepends=()
    checkdepends=()
    pkgver=""
    codename_depends="${VERSION_CODENAME}_depends"
    codename_makedepends="${VERSION_CODENAME}_makedepends"
    eval "${codename_depends}=()"
    eval "${codename_makedepends}=()"

    if [[ "${EDIT}" == "true" ]]; then
        "${EDITOR:-$VISUAL}" "${pkgname}"/PKGBUILD || {
            fatal 'could not edit PKGBUILD'
        }
    fi

    source "${pkgname}/PKGBUILD"

    # new_optdepends=()
    # for depend in "${optdepends[@]}"; do
    #     new_optdepends+=( "${depend%:*}")
    # done

    codename_depends="${VERSION_CODENAME}_depends"
    codename_makedepends="${VERSION_CODENAME}_makedepends"
    [[ "${!codename_depends}" != "" ]] && eval "depends=(\${$codename_depends[*]})"
    [[ "${!codename_makedepends}" != "" ]] && eval "makedepends=(\${$codename_makedepends[*]})"

    echo "${pkgname}/PKGBUILD"

    info "installing dependencies of ${pkgname}"
    for depend in "${depends[@]}" "${makedepends[@]}" "${checkdepends[@]}"; do # "${new_optdepends[@]}"; do
        dpkg-query -W -f='${Status}' "${depend}" 2>/dev/null | grep -q "ok installed" && true || { _install "$depend"; }
    done

    echo "building ${pkgname}"
    cd "${HOME}/.cache/una/pkgs/${pkgname}" && ( makedeb -s || fatal 'an error occurred when building the package' )
    LC_ALL=C dpkg-query -W -f='${Status}' "${pkgname}" 2>/dev/null | grep -q "ok installed" && re='re' || true
    for pkg in ./$pkgname*.deb; do sudo apt-get "${re}install" -y --no-install-recommends "$pkg" || fatal 'an error occurred when installing the package'; done

    sudo touch /var/lib/una/status && sudo cp /var/lib/una/status /var/lib/una/status.old
    grep -q "^${pkgname} " /var/lib/una/status && grep -v "^${pkgname} " /var/lib/una/status 2>/dev/null | sudo tee /var/lib/una/status &>/dev/null
    printf "\n${pkgname} ${pkgver}" | sudo tee -a /var/lib/una/status &>/dev/null
    grep -v "^$" /var/lib/una/status 2>/dev/null | sudo tee /var/lib/una/status &>/dev/null
}

_upgrade() {
    if [[ "$1" != "" ]] && [[ "$1" != "updates" ]]; then
        _install "$1" force; return;
    fi

    [[ "$1" == "updates" ]] || info 'upgrading MPR packages'
    grep -v '^$' /var/lib/una/status | while IFS= read -r line; do
        [[ $(upgrade_command "$line") == "" ]] && continue
        [[ "$1" == "updates" ]] && upgrade_command "$line" || true
        [[ "$1" == "updates" ]] || $(upgrade_command "$line")
    done
    [[ "$1" == "updates" ]] && return || true

    echo
    info 'upgrading APT packages'
    sudo apt-get dist-upgrade -y --auto-remove
}

_remove() {
    pkgname="${1:?}"

    sudo apt-get purge -y "${pkgname}"

    sudo touch /var/lib/una/status && sudo cp /var/lib/una/status /var/lib/una/status.old
    grep -q "^${pkgname} " /var/lib/una/status && grep -v "^${pkgname} " /var/lib/una/status 2>/dev/null | grep -v "^$" 2>/dev/null | sudo tee /var/lib/una/status &>/dev/null
}

_search() {
    pkgname="${1:?}"

    [[ ${#pkgname} -lt 2 ]] && fatal 'search string too short (the length should be greater than 1)'

    curl -s "https://mpr.makedeb.org/rpc?v=5&type=search&arg=${pkgname}" | jq -cr ".results[] | \"${blue}\(.Name)/\(.Version) ${cyan}[MPR]${normal}\n  \(.Description)\""

    for pkgname in $(apt-cache pkgnames hello 2>/dev/null); do
        echo "${blue}${pkgname}/$(LANG=C apt-cache show ${pkgname} | grep '^Version: ' | sed '0,/Version: /{s/Version: //}') ${cyan}[APT]${normal}"
        echo "  $(LANG=C apt-cache show ${pkgname} | grep '^Description-en: ' | sed '0,/Description-en: /{s/Description-en: //}')"
    done
}

_info() {
    pkgname="${1:?}"

    python3 - "${pkgname}" <<'EOF' || ( apt-cache show "${pkgname}" 2>/dev/null || fatal "this package doesn't exist or you're not connected to a network" )
import requests, sys, os

from datetime import datetime

class color:
   PURPLE = '\033[95m'
   CYAN = '\033[96m'
   DARKCYAN = '\033[36m'
   BLUE = '\033[94m'
   GREEN = '\033[92m'
   YELLOW = '\033[93m'
   RED = '\033[91m'
   BOLD = '\033[1m'
   UNDERLINE = '\033[4m'
   END = '\033[0m'

try:
    resp = requests.get(f"https://mpr.makedeb.org/rpc?v=5&type=info&arg={sys.argv[1]}")
    pkginfo = resp.json()
    print(color.BOLD + 'Name:' + color.END, pkginfo['results'][0]['Name'])
    print(color.BOLD + 'Maintainer:' + color.END, pkginfo['results'][0]['Maintainer'])
    print(color.BOLD + 'Last modified:' + color.END, datetime.fromtimestamp(pkginfo['results'][0]['LastModified']))
    print(color.BOLD + 'Description:' + color.END, pkginfo['results'][0]['Description'])
    print(color.BOLD + 'Upstream URL:' + color.END, pkginfo['results'][0]['URL'])
    print(color.BOLD + 'Version:' + color.END, pkginfo['results'][0]['Version'])
    print(color.BOLD + 'Git Clone URL:' + color.END, 'https://mpr.makedeb.org/' + pkginfo['results'][0]['Name'] + '.git')
    print(color.BOLD + 'Depends:' + color.END)
    try:
        for i, depend in enumerate(pkginfo['results'][0]['Depends']):
            if i == 5:
                print('    ...')
                break
            else:
                print(f"{color.BOLD}  - {color.END}{depend}")
    except:
        print()
except:
    sys.exit(1)
EOF
}

_update() {
    if [[ "$1" == "user" ]]; then
        { curl -qs 'https://mpr.makedeb.org/packages-meta-ext-v1.json.gz' | gunzip | tee ~/.cache/una/cache &>/dev/null; } || fatal 'are you sure you are connected to a network?'
    else
        echo
        sudo echo -n
        ( sudo apt-get update &>/dev/null || true; ) & _spinner 'updating APT cache'
        tput civis
        (
            { curl -qs 'https://mpr.makedeb.org/packages-meta-ext-v1.json.gz' | gunzip | sudo tee /var/lib/una/cache &>/dev/null; } || fatal 'are you sure you are connected to a network?'
            { curl -qs 'https://mpr.makedeb.org/packages-meta-ext-v1.json.gz' | gunzip | tee ~/.cache/una/cache &>/dev/null; } || fatal 'are you sure you are connected to a network?'
        ) & _spinner 'updating MPR cache'
        info "${bold}updated cache successfully${normal}"
    fi
}

_clone() {
    pkgname="$1"

    [[ -d "$pkgname" ]] && { info "The directory ${pkgname} already exists. Do you want to overwrite it? (press ENTER to proceed, or ^C to exit)"; }
    read; rm -rf "$pkgname"
    LC_ALL=C git clone "https://mpr.makedeb.org/${pkgname}.git" 2>&1 | grep -q 'empty repository' && \
        { rm -rf "${pkgname}"; fatal "this MPR package doesn't exist or an error occured"; } || info "Cloned the git repo"
}

if [[ "$EUID" == "0" ]] && [[ "$3" != "root" ]]; then
    fatal 'running as root can cause problems'
fi

# check if lockfile exists
LOCKFILE=/tmp/una.lock
if [[ -e /tmp/una.lock ]] && kill -0 "$(cat "${LOCKFILE}")" 2>/dev/null; then
    fatal "already running as PID $(cat "${LOCKFILE}")"
    exit
fi

# create lockfile
trap "rm -f "${LOCKFILE:?}"; tput cnorm; exit" INT TERM EXIT
echo $$ > ${LOCKFILE}

if [[ ! -d '/var/lib/una' ]] || { [[ ! -f '/var/lib/una/status' ]] || { [[ ! -f "$HOME/.config/autostart/una-updater.desktop" ]] || [[ ! -f '/var/lib/una/cache' ]]; } }; then
    echo
    info 'creating una directory and config files'
    mkdir -p "${HOME}/.config/autostart"
    cat <<'EOF' >"${HOME}/.config/autostart/una-updater.desktop"
[Desktop Entry]
Type=Application
Exec=una-updater
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Name=Una Updater
Comment=Auto-updater for APT and MPR packages.
EOF
    sudo mkdir -p /var/lib/una
    sudo touch /var/lib/una/status /var/lib/una/cache
    grep -q '^una-bin ' /var/lib/una/status 2>/dev/null || \
        { echo "una-bin $(LC_ALL=C dpkg-query --show --showformat '${Version}\n' una-bin)" | sudo tee /var/lib/una/status &>/dev/null; }
    echo
    info 'looks like you are a new user or una was updated'
    info "run una update every once in a while to update una's package cache"
    info "you might face issues if it's outdated"
    sleep 3

    _update
    echo
fi

mkdir -p ~/.cache/una

if [[ "$1" == "install" ]] && [[ "$2" != "" ]]; then
    if [[ "$2" == "--edit" ]]; then
        export EDIT=true
        shift
    fi
    _install "$2";
elif [[ "$1" == "update" ]]; then
    _update "$2";
elif [[ "$1" == "updates" ]]; then
    updates="$(_upgrade updates)"
    [[ -z "${updates}" ]] && exit 1 || echo "${updates}"
elif [[ "$1" == "list" ]]; then
    dpkg -l;
elif [[ "$1" == "clone" ]]; then
    _clone "$2";
elif [[ "$1" == "remove" ]] || [[ "$1" == "purge" ]]; then
    _remove "$2";
elif [[ "$1" == "upgrade" ]]; then
    _upgrade "$2";
elif [[ "$1" == "search" ]] && [[ "$2" != "" ]]; then
    echo
    tput civis; results="$(_search "$2" & _spinner ${green}searching${normal})"; tput cnorm
    echo -e "$results" | less;
elif { [[ "$1" == "info" ]] || [[ "$1" == "show" ]]; } && [[ "$2" != "" ]]; then
    _info "$2";
elif [[ -z "$1" ]] || [[ "$1" == "help" ]]; then
    _help;
fi

# remove lockfile
rm -f "${LOCKFILE:?}"
