#!/bin/bash

bold="$(tput bold)"
normal="$(tput sgr0)"

set -e

fatal() {
    echo -e "${bold}fatal error${normal}: $@"
    kill $$
}

sshell_exit() {
    kill $$
}

info() {
    echo -e "${bold}info${normal}: $@"
}

trim_string() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    printf '%s' "$var"
}

update_command() {
    local pkg="$1"

    python3 - "${pkg}" <<'EOF'
import requests, sys

try:
    resp = requests.get('https://mpr.makedeb.org/packages-meta-ext-v1.json.gz')
    paklist = resp.json()
    all_packages = [ x["Name"] for x in paklist ]
    all_versions = [ x["Version"] for x in paklist ]

    data = sys.argv[1]

    if all_versions[all_packages.index(data.split(' ')[0])] != data.split(' ')[1]:
        print(f"_install {data.split(' ')[0]} force")
except:
    print('')
EOF
}

_help() {
    echo -e "${bold}Una - a complete MPR helper${normal}"
    echo
    echo "Syntax: una <COMMAND> [PACKAGE]"
    echo
    echo "commands:"
    echo
    echo "  install     Install a package."
    echo "  update      Update the APT cache."
    echo "  upgrade     Upgrade all installed packages."
    echo "  remove      Remove a package."
    echo "  list        List installed packages."
    echo "  info        Show package information."
    echo "  search      Search for packages."
    echo
    echo "${bold}Do not use 'apt remove' or 'apt purge' on MPR packages."
    echo "The package will get reinstalled when updating if an update for it is available."
    echo "Instead, use 'una remove' (replacement for 'apt purge' for MPR packages)."
}

_install() {
    sudo mkdir -p /var/lib/una

    pkgname="$1"

    if [ "$2" != "force" ]; then
        LC_ALL=C dpkg-query -W -f='${Status}' "${pkgname}" 2>/dev/null | grep -q "ok installed" && (
            fatal "${pkgname} is already installed"
        ) || true
    fi

    info 'creating build directory'
    rm -rf "${HOME}/.cache/una/pkgs/${pkgname}"
    mkdir -p ~/.cache/una/pkgs && cd ~/.cache/una/pkgs

    info "cloning ${pkgname}"
    LC_ALL=C git clone "https://mpr.makedeb.org/${pkgname}.git" 2>&1 | grep -q 'empty repository' && \
        ( sudo apt-get install -y "${pkgname}" && ( rmdir "${HOME}/.cache/una/pkgs/${pkgname}" &>/dev/null || true ) \
        || fatal "this package doesn't exist or an error occured" ) || true

    if [ "$2" != "force" ]; then
        LC_ALL=C dpkg-query -W -f='${Status}' "${pkgname}" 2>/dev/null | grep -q "ok installed" && return || true
    fi

    source "${pkgname}/PKGBUILD"

    new_optdepends=()
    for depend in "${optdepends[@]}"; do
        new_optdepends+=( $(echo "${depend}" | cut -d':' -f1) )
    done

    source /etc/os-release
    codename_depends="${VERSION_CODENAME}_depends"
    codename_makedepends="${VERSION_CODENAME}_makedepends"
    [ "${!codename_depends}" != "" ] && eval "depends=(\${$codename_depends[*]})"
    [ "${!codename_makedepends}" != "" ] && eval "depends=(\${$codename_makedepends[*]})"

    info "installing dependencies of ${pkgname}"
    for depend in "${depends[@]}" "${makedepends[@]}" "${checkdepends[@]}" "${new_optdepends[@]}"; do
        dpkg-query -W -f='${Status}' "${depend}" 2>/dev/null | grep -q "ok installed" && true || _install "$depend"
        sudo apt-mark auto "$depend" &>/dev/null
        pkgname="$1"
    done

    pkgname="$1"

    echo "building ${pkgname}"
    cd "${HOME}/.cache/una/pkgs/${pkgname}" && makedeb -i

    sudo touch /var/lib/una/status && sudo cp /var/lib/una/status /var/lib/una/status.old
    grep -q "^${pkgname} " /var/lib/una/status && grep -v "^${pkgname} " /var/lib/una/status 2>/dev/null | sudo tee /var/lib/una/status &>/dev/null
    printf "\n${pkgname} $(dpkg-query --showformat='${Version}' --show ${pkgname})" | sudo tee -a /var/lib/una/status &>/dev/null
    grep -v "^$" /var/lib/una/status 2>/dev/null | sudo tee /var/lib/una/status &>/dev/null
}

_upgrade() {
    if [ "$1" != "" ]; then
        _install "$1" force; return;
    fi

    info 'upgrading MPR packages'
    grep -v '^$' /var/lib/una/status | while IFS= read -r line; do
        $(update_command "$line")
    done
    echo
    info 'upgrading APT packages'
    sudo apt upgrade -y
}

_remove() {
    pkgname="$1"

    sudo apt-get purge -y "${pkgname}"

    sudo touch /var/lib/una/status && sudo cp /var/lib/una/status /var/lib/una/status.old
    grep -q "^${pkgname} " /var/lib/una/status && grep -v "^${pkgname} " /var/lib/una/status 2>/dev/null | grep -v "^$" 2>/dev/null | sudo tee /var/lib/una/status &>/dev/null
}

_search() {
    pkgname="$1"

    info 'showing MPR packages'

    [ ${#pkgname} -lt 2 ] && fatal 'search string too short (the length should be greater than 1)'

    CURL=$(curl -s "https://mpr.makedeb.org/rpc?v=5&type=search&arg=${pkgname}")
    paste <(echo "$(echo "$CURL" | jq --raw-output '.results[].Name'):") <(echo $CURL | jq --raw-output '.results[].Description')

    echo
    info 'showing APT packages'
    apt-cache search "${pkgname}" 2>/dev/null
}

_info() {
    pkgname="$1"

    CURL=$(curl -s "https://mpr.makedeb.org/rpc?v=5&type=info&arg=${pkgname}")
    python3 - "${pkgname}" <<'EOF' || ( apt-cache show "${pkgname}" 2>/dev/null || fatal "this package doesn't exist or you're not connected to a network" )
import requests, sys, os

from datetime import datetime

class color:
   PURPLE = '\033[95m'
   CYAN = '\033[96m'
   DARKCYAN = '\033[36m'
   BLUE = '\033[94m'
   GREEN = '\033[92m'
   YELLOW = '\033[93m'
   RED = '\033[91m'
   BOLD = '\033[1m'
   UNDERLINE = '\033[4m'
   END = '\033[0m'

try:
    resp = requests.get(f"https://mpr.makedeb.org/rpc?v=5&type=info&arg={sys.argv[1]}")
    pkginfo = resp.json()
    print(color.BOLD + 'Name:' + color.END, pkginfo['results'][0]['Name'])
    print(color.BOLD + 'Maintainer:' + color.END, pkginfo['results'][0]['Maintainer'])
    print(color.BOLD + 'Last modified:' + color.END, datetime.fromtimestamp(pkginfo['results'][0]['LastModified']))
    print(color.BOLD + 'Description:' + color.END, pkginfo['results'][0]['Description'])
    print(color.BOLD + 'Upstream URL:' + color.END, pkginfo['results'][0]['URL'])
    print(color.BOLD + 'Git Clone URL:' + color.END, 'https://mpr.makedeb.org/' + pkginfo['results'][0]['Name'] + '.git')
    print(color.BOLD + 'Depends:' + color.END)
    for i, depend in enumerate(pkginfo['results'][0]['Depends']):
        if i == 5:
            print('    ...')
            break
        else:
            print(f"{color.BOLD}  - {color.END}{depend}")
except:
    sys.exit(1)
EOF
}

[ "$EUID" = "0" ] && fatal 'running as root can cause problems'

# check if lockfile exists
LOCKFILE=/tmp/una.lock
if [ -e /tmp/una.lock ] && kill -0 $(cat "${LOCKFILE}"); then
    fatal "already running as PID $(cat "${LOCKFILE}")"
    exit
fi

# create lockfile
trap "rm -f ${LOCKFILE}; exit" INT TERM EXIT
echo $$ > ${LOCKFILE}

if [ "$1" = "install" ] && [ "$2" != "" ]; then
	_install "$2";
elif [ "$1" = "update" ]; then
	sudo apt-get update;
elif [ "$1" = "list" ]; then
    dpkg -l;
elif [ "$1" = "remove" ] || [ "$1" = "purge" ]; then
    _remove "$2";
elif [ "$1" = "upgrade" ]; then
    _upgrade "$2";
elif [ "$1" = "search" ] && [ "$2" != "" ]; then
    _search "$2";
elif ( [ "$1" = "info" ] || [ "$1" = "show" ] ) && [ "$2" != "" ]; then
    _info "$2";
elif [ "$1" = "" ]; then
    _help;
fi

# remove lockfile
rm -f "${LOCKFILE}"
